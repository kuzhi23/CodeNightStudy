### Reference

[로우 레벨로 살펴보는 Node.js 이벤트 루프](https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/)  
[Node.js 동작원리](https://medium.com/@vdongbin/node-js-동작원리-single-thread-event-driven-non-blocking-i-o-event-loop-ce97e58a8e21)

# nodejs의 이벤트루프

얼마 전 nodejs는 완전한 싱글스레드가 아니란걸 깨달았고,(그냥 싱글스레드라고 맘편히 생각하자)  
이벤트루프라는 녀석이 싱글스레드라는걸 알게됐다.  
그런데 이 이벤트루프가 있는곳이 js를 실행시키는 엔진에 있는게 **아니다**  
실제로 이벤트루프가 실행되는 곳은 Nodejs에서는 libuv에서 실행이되는데,(브라우저도 이벤트루프를 실행시키는곳은 따로존재함)  
이 이벤트루프라는걸 통해 main.js 라는 스크립트를 어떤 과정으로 실행하고 비동기 작업을 처리하는지 살펴보자.

## 이벤트 루프가 활성 상태인지 알아본다.

즉 이벤트루프를 통해 해야할 작업이 있는지 확인한다.
만약 이벤트 루프를 돌릴 필요가 없다면 nodejs는 이벤트루프를 종료한다.  
그게 아니라 실행할 작업이 있다면 다음 단계로 향한다.

## Timer단계

이 단계에 오면 오름차순으로 힘에 정렬된 타이머 스크립트들을 제일 먼저 저장된 순으로 하나씩 깐다.  
그리고 현재시간과 타이머의 시간과 반복하는 로직을 통해 타이머의 콜백을 실행할 시간이 됐는지 검사한다.  
만약 실행할 시간이 됐으면, 실행을 시키고 다음 타이머를 확인한다. 적절한 시간이 되지않았다면,  
바로 다음단계로 넘어간다.

## Pending I/O단계

이번 단계에서는 가장먼저 이전 작업들의 콜백이 실행 대기 중인지, pending Queue를 확인한다.  
만약 pending Queue에 대기중인 콜백이 있다면, 실행 한도 초과에 도달할 때까지 큐에있는 콜백을 실행한다.  
이 과정을 거친다면, idle, prepare phase(내부절차적으로만 이용되기 때문에 생략)를 거친 후  
다음 단계인 poll단계로 이동한다.

## Poll 단계

poll에서는 내부의 파일읽기, HTTP 응답 콜백을 담당하는 watcher Queue에 있는 작업들을 실행하게 된다.  
이 작업 역시 Pending I/O단계와 마찬가지로 큐가 비거나 시스템의 실행 한도 초과에 다다를 때까지 계속 된다.  
더 이상 해당 큐에 실행 할 콜백이 없고 다른 큐들에 작업이 없다면 다음단계로 넘어가지 않고 기다린다.  
이 단계에서 무작정 기다리는게 아니라 다음 세개의 조건을 판별한다.

1. Check phase(SetImmedate함수를 처리하는단계)에 실행할 콜백이 있는가?
2. timer가 있는지, 그 타이머를 실행할 수 있는 시간이 되면 timer단계로 간다.
3. 그 외 다른 이 전 큐나 작업이 생긴다면 그 단계로 간다.

## Check 단계

setImmediate 함수를 처리하는 check Queue가 비거나 실행 한도 초과에 도달할 때까지 계속 해서  
콜백함수를 실행시킨다.

## Close callbacks

check단계가 종료되면 close 이벤트에 따른 콜백함수를 실행한다.(리드라인모듈의 .on("close",... 등등)

---

이러한 단계들을 **순차적**으로 거치고 이벤트루프에 더이상 작업이 없다면,  
이벤트 루프는 종료되고 메인스크립트또한 종료된다.
